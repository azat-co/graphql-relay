footer: © NodeProgram.com, Node.University and Azat Mardan 2017
slidenumbers: true

# GraphQL and Relay

^ REST is still very popular, perhaps _most_ popular API architecture. With REST, you declare _resources_ and map HTTP methods to _operations_ against these resources. The problem is, if you want to fetch three users and then

---

### REST is classic

REST has been around since early 2000's, it is everywhere, and it has proven to be stable and maintainable.

So what's the problem?

---

### REST is too stable

---

### REST is too stable

REST comes from times when **API architect** was the boss, and the API design was confirmed, approved and fixed weeks before engineering team would start working on its implementation.

These days, **user** is the boss. Whenever the user feels the app is too slow, a single decision is enough for them to make you lose a fraction of your profit.

Users want a faster and more responsive app, therefore we need better network performance.

^ Back in days, the app was planned and prototyped, and it would take weeks before the first version appeared. Designing such an API that would stay stable for the next few versions was a pretty valuable skill. Nowadays, it's different, the product is delivered continuously, the "version" thing is getting blurry, and requirements may change in a blink of an eye. API design is still valuable as skill, but not any longer valuable as product.

---

### Typical REST workflow

Fetching a list of movies:

```
GET https://api.example.com/v1/movies.json
```

and response would be an array of objects:

```javascript
[{
  "title": "Pirates of the Caribbean: On Stranger Tides",
  // ...
}]
```

^ Let's say, we have a Netflix-like app, and on the main screen, there is the list of movies. A typical REST request contains API URL, API version, resource path and format. It's just perfect until we want to fetch actors for every movie.

---

### Typical REST workflow: actors of movies

Now let's fetch actors:

```
GET https://api/example.com/v1/movies/:movie_id/actors.json
```

The problem: as many extra GET requests as there are movies.

^ It's a very typical problem in RESTful API architecture: when entities are nested, you need to fetch parent entity and then many child entities, and the number of entities multiplied by number of layers can be hure.

---

### Typical REST workflow: let's include!

You may prevent numerous API requests by sometimes including actors and sometimes not, by "includes" query parameter:

```
GET https://api.example.com/v1/movies.json?includes=actors
```

so that the response would be

```javascript
[{
  "title": "Pirates of the Caribbean: On Stranger Tides",
  "actors": [{
    // ...
  }]
  // ...
}]
```

^ That's the most common pattern, after simply putting child entities into REST API response.

---

# Why GraphQL?

We have REST. Why do we need another API architecture?

- The longer a product is in development, the greater chance data model will change.
- REST is good when data model is fixed and never changes.
- REST isn't as good when you need to rewrite the API.

^ REST is established API development standard that's been around for ages. There's a little problem with REST that FB guys didn't like: in RESTful architecture, you have to query every resource separately. There are _at least_ as many different HTTP requests as resources. If resource B depends on resource A, you need to maintain this dependency A-to-B between requests. Typically, if A has `id` property, B has `a_id` property to keep the relation. But once you need any other kind of relationship, you have to rewrite a good amount of API, and nobody really likes rewriting old stuff.


---

### Who invented GraphQL?

---

# Facebook

^ It was Facebook. These guys know pretty much about changing requirements, rapidly evolving product, constant fluctuation of data model, and high expectations of users. It's a technology company, and technology they use must be flawless. No wonder they created something completely new, and this new fortunately turned out to be universal and useful.

---

### GraphQL is 4 years old (REST is 16)

GraphQL is not a "next hot tech". It's been in development since 2012, it'sproven against time, and it has been in production usage for a while.

^ Reference post from FB engineering blog: https://code.facebook.com/posts/1691455094417024/graphql-a-data-query-language/

---

### Who is using GraphQL?

[Who is using GraphQL in production?](https://www.quora.com/Who-is-using-GraphQL-in-production-besides-Facebook-itself) (an actual question on Quora)

> — GitHub, Pinterest, Intuit, Coursera, Shopify and many more.

^ It's a real question and real answer on Quora, see https://www.quora.com/Who-is-using-GraphQL-in-production-besides-Facebook-itself. GraphQL **is** production-ready, and companies **do** love the flexibility and performance it gives.

---

### Let's try it out!

Let's see how GraphQL can be used to build a simple Netflix clone.

^ Once having an idea of building a Netflix clone, you may instantly have RESTful data schema popped out on your mind. Hold on! Let's use GraphQL to perform queries and update data on the back-end.
